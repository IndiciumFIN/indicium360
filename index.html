

Conversa fixada

Conversa com o Gemini
<!DOCTYPE html>

<html lang="pt">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Animação Institucional com Áudio</title>

    <script src="https://cdn.tailwindcss.com"></script>

    <style>

        body {

            margin: 0;

            overflow: hidden;

            font-family: 'Inter', sans-serif;

            background: radial-gradient(ellipse at center, #0d2a4f 0%, #010a1f 70%);

            color: #e6edf3;

            display: flex;

            justify-content: center;

            align-items: center;

            height: 100vh;

            flex-direction: column;

        }

        canvas { display: block; touch-action: none; }

        #overlay {

            position: absolute;

            top: 0;

            left: 0;

            width: 100%;

            height: 100%;

            display: flex;

            justify-content: center;

            align-items: center;

            background-color: rgba(0, 0, 0, 0.7);

            transition: opacity 1s ease-in-out;

            z-index: 200;

            flex-direction: column;

        }

        #text-overlay {

            position: absolute;

            top: 50%;

            left: 50%;

            transform: translate(-50%, -50%);

            text-align: center;

            font-size: 2rem;

            font-weight: bold;

            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);

            opacity: 0;

            transition: opacity 1.5s ease-in-out;

            pointer-events: none;

            z-index: 10;

            width: 80%;

            max-width: 600px;

        }

        #intro-message {

            text-align: center;

            font-size: 1.5rem;

            padding: 20px 40px;

            background-color: rgba(0, 0, 0, 0.7);

            border-radius: 15px;

            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);

            z-index: 100;

            transition: opacity 1s ease-in-out;

        }

        #start-button {

            background-color: #4dd8ff;

            color: #010a1f;

            padding: 1rem 2rem;

            border-radius: 9999px;

            font-size: 1.25rem;

            font-weight: 700;

            border: none;

            cursor: pointer;

            box-shadow: 0 4px 15px rgba(77, 216, 255, 0.5);

            transition: all 0.3s ease;

        }

        #start-button:hover {

            background-color: #87cefa;

            transform: scale(1.05);

            box-shadow: 0 6px 20px rgba(135, 206, 250, 0.7);

        }

        #loading-message {

            margin-top: 1rem;

            font-size: 1rem;

            color: #ccc;

        }

    </style>

</head>

<body>

    <div id="overlay">

        <button id="start-button">Iniciar Animação</button>

        <div id="loading-message" class="hidden">A carregar áudio...</div>

    </div>

    <div id="text-overlay" class="text-white"></div>



    <!-- Carregando as bibliotecas Three.js e os módulos de addons -->

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">

        {

            "imports": {

                "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",

                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"

            }

        }

    </script>



    <script type="module">

        import * as THREE from 'three';

        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';



        let scene, camera, renderer, controls, iconGroup, arcGroup, cometTrail, particleMesh;

        let energyHexagons = [];

        let trail = [];

        let clock = new THREE.Clock();

        let animationStarted = false;

        let currentSceneIndex = 0;

        let isPlayingAudio = false;



        const scenes = [

            { text: "A excelência na enfermagem exige precisão.", camTarget: new THREE.Vector3(0, 0, 0), camPos: new THREE.Vector3(0, 0, 18) },

            { text: "A inovação exige novas soluções.", camTarget: new THREE.Vector3(1.7, 0, 0), camPos: new THREE.Vector3(5, 5, 10) },

            { text: "Da complexidade à clareza. Da incerteza à eficiência. A ferramenta que capacita a sua equipe.", camTarget: new THREE.Vector3(0, 0, 0), camPos: new THREE.Vector3(0, 0, 25) },

            { text: "Realize seus cálculos e aplique suas escalas de enfermagem com apenas alguns cliques!.", camTarget: new THREE.Vector3(0, 0, 0), camPos: new THREE.Vector3(0, 0, 18) }

        ];



        let sceneStartTime;

        let sceneAudioDuration;

        let startCamPos, startCamTarget;



        const textOverlay = document.getElementById('text-overlay');

        const overlay = document.getElementById('overlay');

        const startButton = document.getElementById('start-button');

        const loadingMessage = document.getElementById('loading-message');



        // Função utilitária para converter Base64 para ArrayBuffer

        function base64ToArrayBuffer(base64) {

            const binaryString = window.atob(base64);

            const len = binaryString.length;

            const bytes = new Uint8Array(len);

            for (let i = 0; i < len; i++) {

                bytes[i] = binaryString.charCodeAt(i);

            }

            return bytes.buffer;

        }



        // Função utilitária para converter PCM em formato WAV

        function pcmToWav(pcmData, sampleRate = 16000) {

            const buffer = new ArrayBuffer(44 + pcmData.length * 2);

            const view = new DataView(buffer);



            // RIFF chunk descriptor

            writeString(view, 0, 'RIFF');

            view.setUint32(4, 36 + pcmData.length * 2, true);

            writeString(view, 8, 'WAVE');



            // FMT sub-chunk

            writeString(view, 12, 'fmt ');

            view.setUint32(16, 16, true);

            view.setUint16(20, 1, true); // Linear PCM

            view.setUint16(22, 1, true); // Mono channel

            view.setUint32(24, sampleRate, true);

            view.setUint32(28, sampleRate * 2, true); // byte rate

            view.setUint16(32, 2, true); // block align

            view.setUint16(34, 16, true); // bits per sample



            // data sub-chunk

            writeString(view, 36, 'data');

            view.setUint32(40, pcmData.length * 2, true);



            // PCM data

            let offset = 44;

            for (let i = 0; i < pcmData.length; i++) {

                view.setInt16(offset, pcmData[i], true);

                offset += 2;

            }



            return new Blob([view], { type: 'audio/wav' });

        }



        function writeString(view, offset, string) {

            for (let i = 0; i < string.length; i++) {

                view.setUint8(offset + i, string.charCodeAt(i));

            }

        }



        // Função para obter áudio TTS da API do Gemini

        async function getTTSAudio(text) {

            let attempt = 0;

            const maxAttempts = 5;

            const delay = (attempt) => Math.pow(2, attempt) * 1000 + Math.random() * 1000;



            while (attempt < maxAttempts) {

                try {

                    const payload = {

                        contents: [{

                            parts: [{ text: text }]

                        }],

                        generationConfig: {

                            responseModalities: ["AUDIO"],

                            speechConfig: {

                                voiceConfig: {

                                    prebuiltVoiceConfig: { voiceName: "Rasalgethi" } // Voz masculina e amigável

                                }

                            }

                        },

                        model: "gemini-2.5-flash-preview-tts"

                    };

                    const apiKey = "";

                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;



                    const response = await fetch(apiUrl, {

                        method: 'POST',

                        headers: { 'Content-Type': 'application/json' },

                        body: JSON.stringify(payload)

                    });



                    if (!response.ok) {

                        throw new Error(`HTTP error! status: ${response.status}`);

                    }



                    const result = await response.json();

                    const part = result?.candidates?.[0]?.content?.parts?.[0];

                    const audioData = part?.inlineData?.data;

                    const mimeType = part?.inlineData?.mimeType;



                    if (audioData && mimeType && mimeType.startsWith("audio/")) {

                        const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);

                        const pcmData = base64ToArrayBuffer(audioData);

                        const pcm16 = new Int16Array(pcmData);

                        const wavBlob = pcmToWav(pcm16, sampleRate);

                        return URL.createObjectURL(wavBlob);

                    } else {

                        console.error("Dados de áudio não encontrados na resposta da API.");

                    }

                } catch (error) {

                    console.error(`Tentativa ${attempt + 1} falhou ao obter áudio:`, error);

                    if (attempt < maxAttempts - 1) {

                        await new Promise(resolve => setTimeout(resolve, delay(attempt)));

                    } else {

                        console.error("Todas as tentativas de obter áudio falharam.");

                    }

                }

                attempt++;

            }

            return null; // Retorna null se todas as tentativas falharem

        }



        async function playScene(index) {

            if (index >= scenes.length) {

                textOverlay.style.opacity = '0';

                return;

            }



            const sceneData = scenes[index];



            // Exibir texto na sobreposição

            textOverlay.innerText = sceneData.text;

            textOverlay.style.opacity = '1';



            // Armazenar a posição inicial da câmara para interpolação

            startCamPos = camera.position.clone();

            startCamTarget = controls.target.clone();



            isPlayingAudio = true;

            const audioUrl = await getTTSAudio(sceneData.text);

            

            if (audioUrl) {

                const audio = new Audio(audioUrl);

                audio.onended = () => {

                    isPlayingAudio = false;

                    textOverlay.style.opacity = '0';

                    currentSceneIndex++;

                    playScene(currentSceneIndex);

                };

                audio.play();

                sceneAudioDuration = audio.duration;

                sceneStartTime = clock.getElapsedTime();

            } else {

                console.error("Não foi possível obter áudio. Passando para a próxima cena em 5 segundos.");

                setTimeout(() => {

                    isPlayingAudio = false;

                    textOverlay.style.opacity = '0';

                    currentSceneIndex++;

                    playScene(currentSceneIndex);

                }, 5000);

            }

        }



        // Função de inicialização da cena Three.js

        function init() {

            // --- Configuração Básica ---

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });

            renderer.setSize(window.innerWidth, window.innerHeight);

            document.body.appendChild(renderer.domElement);



            camera.position.z = 18;



            // --- Controles de Interação ---

            controls = new OrbitControls(camera, renderer.domElement);

            controls.enableDamping = true;

            controls.dampingFactor = 0.05;

            controls.screenSpacePanning = false;

            controls.minDistance = 5;

            controls.maxDistance = 30;

        }



        // Função de criação dos elementos 3D

        function createElements() {

             // --- Ícones Médicos Energizados (Dourados) ---

            function createIcon(svgPath, position) {

                const loader = new THREE.TextureLoader();

                const texture = loader.load(`data:image/svg+xml;base64,${btoa(svgPath)}`);

                const material = new THREE.MeshBasicMaterial({ 

                    map: texture, 

                    transparent: true, 

                    side: THREE.DoubleSide,

                    color: 0xffd700

                });

                const geometry = new THREE.PlaneGeometry(1.5, 1.5);

                const icon = new THREE.Mesh(geometry, material);

                icon.position.set(position.x, position.y, position.z);

                return icon;

            }



            // Função para criar o contorno hexagonal com efeito de energia

            function createHexagonOutline(position) {

                const hexagonGroup = new THREE.Group();

                const shape = new THREE.Shape();

                const size = 1;

                shape.moveTo(size, 0);

                for (let i = 1; i <= 6; i++) {

                    shape.lineTo(size * Math.cos(i * Math.PI / 3), size * Math.sin(i * Math.PI / 3));

                }

                const points = shape.getPoints();

                const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);

                

                const lineMaterial = new THREE.LineBasicMaterial({ color: 0x4dd8ff, linewidth: 2 });

                const mainLine = new THREE.Line(lineGeometry, lineMaterial);

                

                const energyMaterial = new THREE.LineBasicMaterial({ color: 0x87cefa, transparent: true });

                const energyLine = new THREE.Line(lineGeometry, energyMaterial);

                energyLine.scale.set(1.1, 1.1, 1.1);

                

                hexagonGroup.add(mainLine);

                hexagonGroup.add(energyLine);

                hexagonGroup.position.set(position.x, position.y, position.z);

                

                hexagonGroup.userData.energyLine = energyLine;

                return hexagonGroup;

            }



            const svgs = {

                heartbeat: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M54.3 21.5c-5.3-5.3-13.8-5.3-19.1 0L32 24.7l-3.2-3.2c-5.3-5.3-13.8-5.3-19.1 0-5.3 5.3-5.3 13.8 0 19.1l22.3 22.3 22.3-22.3c5.3-5.3 5.3-13.8 0-19.1z" fill="none" stroke="#ffd700" stroke-width="3"/><path d="M4 32h8l6-16 8 24 6-12h8" fill="none" stroke="#ffd700" stroke-width="3" stroke-linecap="round"/></svg>`,

                atom: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="4" fill="#ffd700"/><ellipse cx="32" cy="32" rx="26" ry="10" stroke="#ffd700" stroke-width="3" fill="none" transform="rotate(45 32 32)"/><ellipse cx="32" cy="32" rx="26" ry="10" stroke="#ffd700" stroke-width="3" fill="none" transform="rotate(-45 32 32)"/><ellipse cx="32" cy="32" rx="26" ry="10" stroke="#ffd700" stroke-width="3" fill="none"/></svg>`,

                calculator: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="12" y="8" width="40" height="48" rx="4" stroke="#ffd700" stroke-width="3" fill="none"/><path d="M18 16h28v10H18z" stroke="#ffd700" stroke-width="3" fill="none"/><circle cx="22" cy="34" r="2" fill="#ffd700"/><circle cx="32" cy="34" r="2" fill="#ffd700"/><circle cx="42" cy="34" r="2" fill="#ffd700"/><circle cx="22" cy="42" r="2" fill="#ffd700"/><circle cx="32" cy="42" r="2" fill="#ffd700"/><circle cx="42" cy="42" r="2" fill="#ffd700"/><circle cx="22" cy="50" r="2" fill="#ffd700"/><circle cx="32" cy="50" r="2" fill="#ffd700"/><circle cx="42" cy="50" r="2" fill="#ffd700"/></svg>`,

                nursingLamp: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M22.2 40h-12a2 2 0 00-2 2v10a2 2 0 002 2h31.6a2 2 0 002-2V42a2 2 0 00-2-2H32m0-24v24m-10 0h20m-14-20a6 6 0 016-6 6 6 0 016 6 2 2 0 01-2 2h-8a2 2 0 01-2-2z" fill="none" stroke="#ffd700" stroke-width="3"/><path d="M32 10a4 4 0 010-8 4 4 0 010 8z" fill="#ffd700"/></svg>`,

                syringe: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M48 16L20 44m20-12l-8 8" stroke="#ffd700" stroke-width="3" fill="none"/><path d="M12 32l-8 8h12l8-8-12-12z" stroke="#ffd700" stroke-width="3" fill="none"/><path d="M52 8l8 8-12 12-8-8z" stroke="#ffd700" stroke-width="3" fill="none"/></svg>`,

                stethoscope: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M16 20a8 8 0 0116 0v24c0 6.6-5.4 12-12 12S8 50.6 8 44V24" fill="none" stroke="#ffd700" stroke-width="3"/><path d="M48 20a8 8 0 00-16 0v24c0 6.6 5.4 12 12 12s12-5.4 12-12V24" fill="none" stroke="#ffd700" stroke-width="3"/><circle cx="24" cy="12" r="4" fill="#ffd700"/><circle cx="40" cy="12" r="4" fill="#ffd700"/><circle cx="28" cy="52" r="10" stroke="#ffd700" stroke-width="3" fill="none"/></svg>`,

                magnifyingGlass: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="28" cy="28" r="18" stroke="#ffd700" stroke-width="3" fill="none"/><path d="M42 42l14 14" stroke="#ffd700" stroke-width="3" stroke-linecap="round"/></svg>`,

                hourglass: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M16 8h32v16L32 40 16 24V8zM16 56h32V40L32 24 16 40v16z" stroke="#ffd700" stroke-width="3" fill="none"/></svg>`,

                medicalChart: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M44 14h-4a6 6 0 00-12 0h-4a4 4 0 00-4 4v38a4 4 0 004 4h20a4 4 0 004-4V18a4 4 0 00-4-4z" fill="none" stroke="#ffd700" stroke-width="3"/><path d="M32 14a2 2 0 11-2-2 2 2 0 012 2z" fill="#ffd700"/><path d="M24 28h16m-16 8h16m-16 8h8" fill="none" stroke="#ffd700" stroke-width="3" stroke-linecap="round"/></svg>`,

            };



            iconGroup = new THREE.Group();

            const hexPositions = [

                { x: 0, y: 0, z: 0, icon: 'heartbeat' }, { x: 1.7, y: 1, z: 0, icon: 'atom' },

                { x: 1.7, y: -1, z: 0, icon: 'calculator' }, { x: 0, y: -2, z: 0, icon: 'nursingLamp' },

                { x: -1.7, y: -1, z: 0, icon: 'syringe' }, { x: -1.7, y: 1, z: 0, icon: 'stethoscope' },

                { x: -3.4, y: 0, z: 0, icon: 'magnifyingGlass' }, { x: 0, y: 2, z: 0, icon: 'hourglass' },

                { x: 3.4, y: 0, z: 0, icon: 'medicalChart' },

            ];



            hexPositions.forEach(pos => {

                const icon = createIcon(svgs[pos.icon], pos);

                const hexagon = createHexagonOutline(pos);

                iconGroup.add(icon);

                iconGroup.add(hexagon);

                energyHexagons.push(hexagon);

            });

            scene.add(iconGroup);



            // --- Arcos Circulares e Efeitos ---

            arcGroup = new THREE.Group();

            const arcRadius = 8;

            const mainArcColor = 0x4dd8ff;

            

            const curve = new THREE.EllipseCurve(0, 0, arcRadius, arcRadius, Math.PI * 0.8, Math.PI * 2.2, false, 0);

            const points = curve.getPoints(100);

            const geometry = new THREE.BufferGeometry().setFromPoints(points);

            const material = new THREE.LineBasicMaterial({ color: mainArcColor });

            arcGroup.add(new THREE.Line(geometry, material));

            

            const numLines = 50, angleRange = Math.PI * 1.4;

            for (let i = 0; i <= numLines; i++) {

                const angle = (Math.PI * 0.8) + (i / numLines) * angleRange;

                const lineGeom = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, -0.15, 0), new THREE.Vector3(0, 0.15, 0)]);

                const line = new THREE.Line(lineGeom, new THREE.LineBasicMaterial({ color: mainArcColor }));

                line.position.set(arcRadius * Math.cos(angle), arcRadius * Math.sin(angle), 0);

                line.rotation.z = angle;

                arcGroup.add(line);

            }



            const lightPointMaterial = new THREE.MeshBasicMaterial({ color: 0x87cefa });

            const lightPointGeometry = new THREE.SphereGeometry(0.2, 16, 16);

            const lightPoint1 = new THREE.Mesh(lightPointGeometry, lightPointMaterial);

            const lightPoint2 = new THREE.Mesh(lightPointGeometry, lightPointMaterial);

            lightPoint1.position.copy(curve.getPoint(0));

            lightPoint2.position.copy(curve.getPoint(1));

            arcGroup.add(lightPoint1, lightPoint2);

            scene.add(arcGroup);



            // --- Efeito Cometa Aprimorado ---

            cometTrail = new THREE.Group();

            const trailLength = 15;

            trail = [];

            for (let i = 0; i < trailLength; i++) {

                const geometry = new THREE.SphereGeometry(0.15, 8, 8);

                const material = new THREE.MeshBasicMaterial({ 

                    color: 0xffffff, 

                    transparent: true,

                    opacity: 1.0 - (i / trailLength) 

                });

                const segment = new THREE.Mesh(geometry, material);

                trail.push(segment);

                cometTrail.add(segment);

            }

            scene.add(cometTrail);



            // --- Sistema de Partículas de Fundo (Energia) ---

            const particlesGeometry = new THREE.BufferGeometry();

            const particlesCnt = 5000;

            const posArray = new Float32Array(particlesCnt * 3);

            for (let i = 0; i < particlesCnt * 3; i++) {

                posArray[i] = (Math.random() - 0.5) * 40;

            }

            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));

            const particlesMaterial = new THREE.PointsMaterial({

                size: 0.03, color: 0x4dd8ff, transparent: true, blending: THREE.AdditiveBlending

            });

            particleMesh = new THREE.Points(particlesGeometry, particlesMaterial);

            scene.add(particleMesh);

        }



        // --- Animação ---

        function animate() {

            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();



            if (animationStarted) {

                // Atualiza os controles se a câmara estiver a ser animada

                controls.update();

                

                if(isPlayingAudio) {

                    const sceneData = scenes[currentSceneIndex];

                    const elapsed = elapsedTime - sceneStartTime;

                    const progress = Math.min(1, elapsed / sceneAudioDuration);



                    // Interpola a posição da câmara e o alvo

                    camera.position.lerpVectors(startCamPos, sceneData.camPos, progress);

                    controls.target.lerpVectors(startCamTarget, sceneData.camTarget, progress);

                }

            }

            

            iconGroup.rotation.y = elapsedTime * 0.1;

            arcGroup.rotation.z = -elapsedTime * 0.2;

            particleMesh.rotation.y = elapsedTime * 0.05;



            // Animação da energia dos hexágonos

            energyHexagons.forEach(hex => {

                hex.userData.energyLine.material.opacity = (Math.sin(elapsedTime * 3 + hex.position.x) + 1) / 2 * 0.75;

            });



            // Animação do cometa e sua cauda

            const cometSpeed = 0.2;

            for (let i = 0; i < trail.length; i++) {

                const progress = ((elapsedTime * cometSpeed) - i * 0.01) % 1;

                const position = curve.getPointAt(progress);

                trail[i].position.copy(position);

                const scale = 1.0 - (i / trail.length);

                trail[i].scale.set(scale, scale, scale);

            }



            renderer.render(scene, camera);

        }



        // --- Responsividade ---

        window.addEventListener('resize', () => {

            camera.aspect = window.innerWidth / window.innerHeight;

            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        });



        // Função para iniciar a animação e o áudio

        async function startAnimation() {

            startButton.style.display = 'none';

            loadingMessage.classList.remove('hidden');

            

            // Pré-carregar o áudio da primeira cena para evitar latência

            await getTTSAudio(scenes[0].text);

            

            loadingMessage.classList.add('hidden');

            overlay.style.opacity = '0';

            overlay.style['pointer-events'] = 'none';

            

            animationStarted = true;

            playScene(currentSceneIndex);

        }



        startButton.addEventListener('click', startAnimation);

        

        window.onload = function() {

            init();

            createElements();

            animate();

        };

    </script>

</body>

</html>
